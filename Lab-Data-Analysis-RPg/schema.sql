CREATE SCHEMA stored_data;
COMMENT ON SCHEMA stored_data IS 'Contains all the data uploaded from Excel files generated by VBA code in Macro workbook "prepare_data_macros" for the "Pan T Cell Assay"';
CREATE UNLOGGED TABLE transit_tmp(
    data_row TEXT);
COMMENT ON TABLE transit_tmp IS 'An unlogged table for storing data temporarily while it is processed. Data is expected to be tab-delimited.';
-- FACS data table definitions
DROP TABLE IF EXISTS stored_data.loaded_files_metadata;
CREATE TABLE stored_data.loaded_files_metadata(
    uploaded_excel_file_id TEXT PRIMARY KEY,
    source_excel_file_path TEXT NOT NULL,
    code_version TEXT,
    code_date TEXT,
    tusk_target_name TEXT NOT NULL CHECK(tusk_target_name IN('CD38', 'CD25', 'CD137')),
    assay_type TEXT NOT NULL,
    assay_group TEXT NOT NULL,
    experiment_name TEXT NOT NULL,
    file_description TEXT,
    user_name TEXT,
    uploaded_excel_file_name TEXT NOT NULL,
    database_load_date DATE DEFAULT CURRENT_DATE);
COMMENT ON COLUMN stored_data.loaded_files_metadata.uploaded_excel_file_id IS 'Generated from the MD5 function of the value stored in column uploaded_excel_file_path. Used as a foreign key in table stored_data.pan_tcell_facs_data.';
COMMENT ON COLUMN stored_data.loaded_files_metadata.source_excel_file_path IS 'The full path to the original Excel file that was processed by VBA in prepare_data_macros.xlsm.';
COMMENT ON COLUMN stored_data.loaded_files_metadata.code_version IS 'The VBA code version used in the macro file';
COMMENT ON COLUMN stored_data.loaded_files_metadata.code_date IS 'The last code update';
COMMENT ON COLUMN stored_data.loaded_files_metadata.tusk_target_name IS 'The recognised Tusk target name, e.g. CD38. Constrained by a CHECK.';
COMMENT ON COLUMN stored_data.loaded_files_metadata.assay_group IS 'As selected in the VBA processing form';
COMMENT ON COLUMN stored_data.loaded_files_metadata.assay_type IS 'As selected in the VBA processing form';
COMMENT ON COLUMN stored_data.loaded_files_metadata.experiment_name IS 'Provided by the user in the VBA form. This is a crucial value for tracking and filtering  data';
COMMENT ON COLUMN stored_data.loaded_files_metadata.file_description IS 'Optional value that can be entered by the user to record file-specific points';
COMMENT ON COLUMN stored_data.loaded_files_metadata.user_name IS 'The user name as recorded by VBA during file processing';
COMMENT ON COLUMN stored_data.loaded_files_metadata.uploaded_excel_file_name IS 'The full path of the file used to populate rows in this and the pan_tcells_facs_data_tables. This vile is generated by the Excel VBA application';
COMMENT ON COLUMN stored_data.loaded_files_metadata.database_load_date IS 'Database-generated date that records when the row was inserted into this table';
DROP TABLE IF EXISTS stored_data.pan_tcell_facs_data;
CREATE TABLE stored_data.pan_tcell_facs_data(
  pan_tcell_facs_data_id SERIAL PRIMARY KEY,
  upload_date DATE DEFAULT CURRENT_DATE,
  raw_data_name TEXT, 
  viable_cells REAL, 
  cd4_mfi_cd137 REAL, 
  cd4_mfi_proliferation REAL, 
  cd4_mfi_cd25 REAL, 
  cd4_percent_proliferation REAL, 
  cd4_percent_cd25 REAL, 
  cd4_percent_cd137 REAL, 
  cd8_mfi_cd137 REAL, 
  cd8_mfi_proliferation REAL, 
  cd8_mfi_cd25 REAL, 
  cd8_percent_proliferation REAL, 
  cd8_percent_cd25 REAL, 
  cd8_percent_cd137 REAL, 
  cd4_cell_number REAL, 
  cd8_cell_number REAL, 
  sample_identifier TEXT,
  uploaded_excel_file_id TEXT NOT NULL REFERENCES stored_data.loaded_files_metadata(uploaded_excel_file_id));

COMMENT ON TABLE stored_data.pan_tcell_facs_data IS 'Stores FACS data for the "Pan T Cell Assay" that has been analysed by FlowJo with the sample IDs added using VBA code in the macro sheet "prepare_data_macros.xlsm".';
COMMENT ON COLUMN stored_data.pan_tcell_facs_data.pan_tcell_facs_data_id IS 'Auto-generated primary key for table "stored_data.pan_tcell_facs_data"';
COMMENT ON COLUMN stored_data.pan_tcell_facs_data.upload_date IS 'The date that the row was inserted into the table "stored_data.pan_tcell_facs_data".';
COMMENT ON COLUMN stored_data.pan_tcell_facs_data.raw_data_name IS 'This is generated by the software and contains an embedded plate ID flanked by underscores.';
COMMENT ON COLUMN stored_data.pan_tcell_facs_data.viable_cells IS 'viable cells Lymphocytes/ Single Cells/ Single Cells viable cells Freq. of Parent ';
COMMENT ON COLUMN stored_data.pan_tcell_facs_data.cd4_mfi_cd137 IS 'MFI CD137 Lymphocytes/ Single Cells/ Single Cells/ viable cells CD4+ Median CD137';
COMMENT ON COLUMN stored_data.pan_tcell_facs_data.cd4_mfi_proliferation IS 'MFI proliferation Lymphocytes/ Single Cells/ Single Cells/ viable cells CD4+ Median proliferation';
COMMENT ON COLUMN stored_data.pan_tcell_facs_data.cd4_mfi_cd25 IS 'MFI CD25 Lymphocytes/ Single Cells/ Single Cells/ viable cells CD4+ Median CD25';
COMMENT ON COLUMN stored_data.pan_tcell_facs_data.cd4_percent_proliferation IS 'perc prol Lymphocytes/ Single Cells/ Single Cells/ viable cells/ CD4+ %prol histo CD4+ Freq. of Parent ';
COMMENT ON COLUMN stored_data.pan_tcell_facs_data.cd4_percent_cd25 IS 'perc CD25 Lymphocytes/ Single Cells/ Single Cells/ viable cells/ CD4+ CD4+CD25+ Freq. of Parent ';
COMMENT ON COLUMN stored_data.pan_tcell_facs_data.cd4_percent_cd137 IS 'perc CD137 Lymphocytes/ Single Cells/ Single Cells/ viable cells/ CD4+ CD4+CD137+ Freq. of Parent ';
COMMENT ON COLUMN stored_data.pan_tcell_facs_data.cd8_mfi_cd137 IS 'MFI CD137 Lymphocytes/ Single Cells/ Single Cells/ viable cells CD8+ Median CD137';
COMMENT ON COLUMN stored_data.pan_tcell_facs_data.cd8_mfi_proliferation IS 'MFI proliferation Lymphocytes/ Single Cells/ Single Cells/ viable cells CD8+ Median proliferation';
COMMENT ON COLUMN stored_data.pan_tcell_facs_data.cd8_mfi_cd25 IS 'MFI CD25 Lymphocytes/ Single Cells/ Single Cells/ viable cells CD8+ Median CD25';
COMMENT ON COLUMN stored_data.pan_tcell_facs_data.cd8_percent_proliferation IS 'perc prol Lymphocytes/ Single Cells/ Single Cells/ viable cells/ CD8+ %prol histo CD8+ Freq. of Parent ';
COMMENT ON COLUMN stored_data.pan_tcell_facs_data.cd8_percent_cd25 IS 'perc CD25 Lymphocytes/ Single Cells/ Single Cells/ viable cells/ CD8+ CD8+CD25+ Freq. of Parent ';
COMMENT ON COLUMN stored_data.pan_tcell_facs_data.cd8_percent_cd137 IS 'perc CD137 Lymphocytes/ Single Cells/ Single Cells/ viable cells/ CD8+ CD8+CD137+ Freq. of Parent ';
COMMENT ON COLUMN stored_data.pan_tcell_facs_data.cd4_cell_number IS 'To be calculated using a code of some sort';
COMMENT ON COLUMN stored_data.pan_tcell_facs_data.cd8_cell_number IS 'To be calculated using a code of some sort';
COMMENT ON COLUMN stored_data.pan_tcell_facs_data.sample_identifier IS 'Extracted from the plate map and matched to the raw_sample_id using the VBA code in "prepare_data_macros.xlsm"';
COMMENT ON COLUMN stored_data.pan_tcell_facs_data.uploaded_excel_file_id IS 'Table foreign key. Can only load rows into this table if this identifier (MD5 of uploaded Excel file path) exists in the referenced table';

-- Data loading stored procedures
CREATE OR REPLACE FUNCTION get_metadata_value(p_metadata_name TEXT)
RETURNS TEXT
AS
$$
DECLARE
  l_metadata_value TEXT;
BEGIN
  WITH metadata AS
  (SELECT
    (STRING_TO_ARRAY(data_row, E'\t'))[1] metadata_name,
    (STRING_TO_ARRAY(data_row, E'\t'))[2] metadata_value
  FROM 
    public.transit_tmp
  LIMIT 10)
  SELECT metadata_value INTO l_metadata_value FROM metadata WHERE metadata_name = p_metadata_name;
  RETURN l_metadata_value;
END;
$$
LANGUAGE plpgsql;
COMMENT ON FUNCTION get_metadata_value(TEXT) IS $qq$Purpose: Uploaded Excel files contain metadata to populate the table "loaded_files_metadata" that is recorded in the first 10 lines of the database upload file in tab-delimited rows. This function gets a single metadata value for a give metadata name. Example: SELECT get_metadata_value('Assay Group');$qq$;
CREATE OR REPLACE FUNCTION add_row_to_loaded_files_metadata()
RETURNS TEXT
AS
$$
DECLARE
  l_code_version TEXT := get_metadata_value('Code Version');
  l_code_date TEXT := get_metadata_value('Code Date');
  l_tusk_target_name TEXT := get_metadata_value('Tusk Target Name');
  l_excel_source_file_path TEXT := get_metadata_value('Source Excel File Path');
  l_assay_type TEXT := get_metadata_value('Assay Type');
  l_assay_group TEXT := get_metadata_value('Assay Group');
  l_experiment_name TEXT := get_metadata_value('Experiment Name');
  l_file_description TEXT := get_metadata_value('File Description');
  l_user_name TEXT := get_metadata_value('User Name');
  l_upload_excel_file_name TEXT := get_metadata_value('Uploaded Excel File Name');
  l_upload_excel_file_id TEXT := MD5(l_upload_excel_file_name);
BEGIN
  INSERT INTO stored_data.loaded_files_metadata(
	uploaded_excel_file_id, source_excel_file_path, code_version, code_date, tusk_target_name, 
      assay_type, assay_group, experiment_name, file_description, user_name, uploaded_excel_file_name)
	VALUES (l_upload_excel_file_id, l_excel_source_file_path, l_code_version, l_code_date, 
            l_tusk_target_name , l_assay_type, l_assay_group, l_experiment_name, 
            l_file_description, l_user_name, l_upload_excel_file_name);
  RETURN l_upload_excel_file_id;
END;
$$
LANGUAGE plpgsql;
COMMENT ON FUNCTION add_row_to_loaded_files_metadata() IS $qq$Purpose: To take the metadata from the uploaded file in "transit_tmp" and extract each of the metadata values from the leading rows using the function "get_metadata_value()" and then insert them into "loaded_files_metadata". It then returns the MD5 value for the source Excel file (the table PK). Example: SELECT add_row_to_loaded_files_metadata();$qq$;

CREATE OR REPLACE FUNCTION get_real_array_element_at_index(p_tab_separated_input TEXT, p_index_position INTEGER)
RETURNS REAL
AS
$$
DECLARE
  l_elements TEXT[] := STRING_TO_ARRAY(p_tab_separated_input, E'\t');
  l_element TEXT := TRIM(l_elements[p_index_position]);
  l_element_as_real REAL;
BEGIN
  IF isnumeric(l_element) THEN
    l_element_as_real := CAST(l_element AS REAL);
  ELSIF LENGTH(l_element) < 1 THEN
    l_element_as_real := NULL;
  ELSE
    RAISE EXCEPTION 'Cannot coerce given value to REAL or NULL!';
  END IF;
  RETURN l_element_as_real;
END;
$$
LANGUAGE plpgsql;
COMMENT ON FUNCTION get_real_array_element_at_index(TEXT, INTEGER) IS
$qq$
Purpose: Extract REAL numbers from a given tab-delimited string using the given index position integer.
Return value: The extracted REAL value or NULL if the extracted, trimmed element is an empty string.
Exception raised if the extracted value is neither numeric or an empty string.
Testing code:
DO
$$
DECLARE
  l_tab_sep_elements TEXT := 'ONE	2	3.1		wexford';
  l_elements TEXT[] := STRING_TO_ARRAY(l_tab_sep_elements, E'\t');
  l_element_as_real REAL;
BEGIN
  FOR i IN 1 .. ARRAY_LENGTH(l_elements, 1) LOOP
    BEGIN
      l_element_as_real := get_real_array_element_at_index(l_tab_sep_elements, i);
      -- RAISE NOTICE '%', l_element_as_real;
    EXCEPTION
      WHEN OTHERS THEN 
        RAISE NOTICE '%', SQLERRM;
     END;
  END LOOP;
END;
$$
$qq$;


CREATE OR REPLACE FUNCTION upload_pan_tcell_facs_data(p_uploaded_excel_file_id TEXT)
RETURNS INTEGER
AS
$$
DECLARE
  l_rowcount_inserted INTEGER;
BEGIN
  INSERT INTO stored_data.pan_tcell_facs_data(
  	raw_data_name, viable_cells, cd4_mfi_cd137, cd4_mfi_proliferation, 
      cd4_mfi_cd25, cd4_percent_proliferation, cd4_percent_cd25, cd4_percent_cd137, cd8_mfi_cd137, 
      cd8_mfi_proliferation, cd8_mfi_cd25, cd8_percent_proliferation, cd8_percent_cd25, cd8_percent_cd137, 
      cd4_cell_number, cd8_cell_number, sample_identifier, uploaded_excel_file_id)
  SELECT
    (STRING_TO_ARRAY(data_row, E'\t'))[1] raw_data_name,
    get_real_array_element_at_index(data_row, 2) viable_cells,
    get_real_array_element_at_index(data_row, 3) cd4_mfi_cd137,
    get_real_array_element_at_index(data_row, 4) cd4_mfi_proliferation,
    get_real_array_element_at_index(data_row, 5) cd4_mfi_cd25,
    get_real_array_element_at_index(data_row, 6) cd4_percent_proliferation,
    get_real_array_element_at_index(data_row, 7) cd4_percent_cd25,
    get_real_array_element_at_index(data_row, 8) cd4_percent_cd137,
    get_real_array_element_at_index(data_row, 9) cd8_mfi_cd137,
    get_real_array_element_at_index(data_row, 10) cd8_mfi_proliferation,
    get_real_array_element_at_index(data_row, 11) cd8_mfi_cd25,
    get_real_array_element_at_index(data_row, 12) cd8_percent_proliferation,
    get_real_array_element_at_index(data_row, 13) cd8_percent_cd25,
    get_real_array_element_at_index(data_row, 14) cd8_percent_cd137,
    get_real_array_element_at_index(data_row, 15) cd4_cell_number,
    get_real_array_element_at_index(data_row, 16) cd8_cell_number,
    (STRING_TO_ARRAY(data_row, E'\t'))[17] sample_identifier,
    p_uploaded_excel_file_id uploaded_excel_file_id
  FROM
    (SELECT
      data_row
    FROM
      transit_tmp
    OFFSET 10) sq;
  GET DIAGNOSTICS l_rowcount_inserted := ROW_COUNT;
  RETURN l_rowcount_inserted;
END;
$$
LANGUAGE plpgsql;
COMMENT ON FUNCTION upload_pan_tcell_facs_data(TEXT) IS $qq$
Purpose: Insert all the data rows loaded into "transit_tmp" from the VBA code output file into table "pan_tcell_facs_data".
Arguments: The hash code for the path of the uploaded Excel file.
Return value: The number of rows inserted into the table.
Notes:
  This function is not usually called directly but instead is called by "load_facs_data_tables" which also transfers the metadata.
  Calls function "get_real_array_element_at_index(TEXT, INTEGER)" to perform the REAL cast for all columns that contain either numeric data
 or empty strings.
$qq$;

CREATE OR REPLACE FUNCTION load_facs_data_tables()
RETURNS JSONB
AS
$$
DECLARE
  l_uploaded_excel_file_id TEXT;
  l_rowcount_inserted INTEGER;
  l_retvals JSONB;
BEGIN
  l_uploaded_excel_file_id := add_row_to_loaded_files_metadata();
  l_rowcount_inserted := upload_pan_tcell_facs_data(l_uploaded_excel_file_id );
  TRUNCATE TABLE public.transit_tmp;
  l_retvals := ('{"uploaded_excel_file_id": ' || '"' || l_uploaded_excel_file_id || '"' || 
    ', "rowcount_inserted": ' || l_rowcount_inserted || '}')::JSONB;
  RETURN l_retvals;
END;
$$
LANGUAGE plpgsql;
COMMENT ON FUNCTION load_facs_data_tables() IS $qq$Purpose: Wraps functions to load FACS data tables. Returns summary as JSONB. Example:  SELECT load_facs_data_tables();$qq$;


-- Stored procedure code for returning data sets to R
CREATE OR REPLACE FUNCTION get_array_mean(p_replicates REAL[])
RETURNS REAL
AS
$$
DECLARE
  l_mean REAL;
BEGIN
  WITH cte AS
  (SELECT 
    UNNEST(p_replicates) replicate_value)
  SELECT AVG(replicate_value) INTO l_mean FROM cte;
  RETURN l_mean;           
END;
$$
LANGUAGE plpgsql;
-- SELECT get_array_mean(ARRAY[47.4,36.5]::REAL[]);
COMMENT ON FUNCTION get_array_mean(REAL[]) IS $$Given an array of real numbers, return the mean (AVG). Example call: SELECT get_array_mean(ARRAY[47.4,36.5]::REAL[]);$$;

-- Use the following two functions to return data to the R Shiny client. The first prepares the data but is not called directly and the second one is the one that is used.
DROP FUNCTION get_single_datatype_arrays(TEXT, TEXT);
CREATE  OR REPLACE FUNCTION get_single_datatype_arrays(p_experiment_name TEXT, p_column_name TEXT)
RETURNS TABLE(uploaded_excel_file_basename TEXT, sample_identifier TEXT, antibody_ids TEXT[], 
              antibody_concentrations REAL[], replicates REAL[], replicates_avg REAL)
AS
$$
BEGIN
  RETURN QUERY EXECUTE format(
      'SELECT
        uploaded_excel_file_basename,  
        sample_identifier,
        ARRAY_AGG(antibody_id) antibody_ids,
        ARRAY_AGG(antibody_concentration) antibody_concentrations,
        ARRAY_AGG(%I) replicates,
        get_array_mean(ARRAY_AGG(%I)) replicates_avg
      FROM 
        stored_data.vw_pan_tcell_facs_data_shiny
      WHERE
        experiment_name = $1
      GROUP BY
        uploaded_excel_file_basename,
        sample_identifier', p_column_name, p_column_name) USING p_experiment_name;
END;
$$
LANGUAGE plpgsql;
SELECT * FROM get_single_datatype_arrays('TSK01_vitro_024', 'viable_cells');
COMMENT ON FUNCTION get_single_datatype_arrays(TEXT, TEXT) IS $qq$Purpose: This is the first of two functions to return a table of results to clients. It returns results for the given column. Example call: SELECT * FROM get_single_datatype_arrays('TSK01_vitro_024', 'viable_cells'); $qq$; 


DROP FUNCTION get_single_datatype(TEXT, TEXT);
CREATE OR REPLACE FUNCTION get_single_datatype(p_experiment_name TEXT, p_column_name TEXT)
RETURNS TABLE(uploaded_excel_file_basename TEXT, sample_identifier TEXT, antibody_id TEXT, 
              antibody_concentration REAL, replicates TEXT, replicates_avg REAL)
AS
$$
BEGIN
  RETURN QUERY
  SELECT
    f.uploaded_excel_file_basename,
    f.sample_identifier,
    f.antibody_ids[1] antibody_id,
    f.antibody_concentrations[1] antibody_concentration,
    ARRAY_TO_STRING(f.replicates, ', ') replicates,
    f.replicates_avg
  FROM
    get_single_datatype_arrays(p_experiment_name, p_column_name) f;
END;
$$
LANGUAGE plpgsql;
SELECT * FROM get_single_datatype('TSK01_vitro_024', 'viable_cells');
COMMENT ON FUNCTION get_single_datatype(TEXT, TEXT) IS $qq$Purpose to return a table of FACS data of a single type to the client. Calls get_single_datatype_arrays(TEXT, TEXT) and processes the arrays that this function returns to give scalars that are either a concatenation or just the first element.$qq$;




CREATE OR REPLACE FUNCTION get_uploaded_excel_basename(p_uploaded_excel_file_id TEXT)
RETURNS TEXT
AS
$$
DECLARE
  l_uploaded_excel_file_name TEXT;
  l_excel_basename TEXT;
  l_excel_fullpath_elements  TEXT[];
  l_excel_fullpath_elements_count INTEGER;
BEGIN
  SELECT
    uploaded_excel_file_name INTO STRICT l_uploaded_excel_file_name 
  FROM
    stored_data.loaded_files_metadata
  WHERE
     uploaded_excel_file_id = p_uploaded_excel_file_id;
  l_excel_fullpath_elements := STRING_TO_ARRAY(l_uploaded_excel_file_name, E'\\');
  l_excel_fullpath_elements_count := ARRAY_LENGTH(l_excel_fullpath_elements, 1);
  l_excel_basename := l_excel_fullpath_elements[l_excel_fullpath_elements_count];
  RETURN REPLACE(l_excel_basename, '.xlsx', '');
END;
$$
LANGUAGE plpgsql;

COMMENT ON FUNCTION get_uploaded_excel_basename(TEXT) IS $qq$ Purpose: To extract the basename from a full path for an uploaded Excel file. Argument: uploaded_excel_file_id in table stored_data.loaded_files_metadata. The basename is used to filter results in the R Shiny interface. Example: SELECT get_uploaded_excel_basename('15c4ad591200b27689ab58c22e91a876');$qq$;


-- Shiny View creation
CREATE OR REPLACE VIEW stored_data.vw_pan_tcell_facs_data_shiny AS
WITH cte AS
  (SELECT
    uploaded_excel_file_id,
    get_uploaded_excel_basename(uploaded_excel_file_id) uploaded_excel_file_basename,
    experiment_name,
    tusk_target_name
  FROM
    stored_data.loaded_files_metadata)
SELECT
  cte.*,
  ptfd.raw_data_name,
  ptfd.sample_identifier,
  CASE
    WHEN isnumeric((STRING_TO_ARRAY(ptfd.sample_identifier, E'_'))[ARRAY_LENGTH((STRING_TO_ARRAY(ptfd.sample_identifier, E'_')), 1) -1]) THEN
      ((STRING_TO_ARRAY(ptfd.sample_identifier, E'_'))[ARRAY_LENGTH((STRING_TO_ARRAY(ptfd.sample_identifier, E'_')), 1) -1])::REAL
    ELSE
      NULL
  END antibody_concentration,
  ptfd.viable_cells,
  ptfd.cd4_mfi_cd137,
  ptfd.cd4_mfi_proliferation,
  ptfd.cd4_mfi_cd25,
  ptfd.cd4_percent_proliferation,
  ptfd.cd4_percent_cd25,
  ptfd.cd4_percent_cd137,
  ptfd.cd8_mfi_cd137,
  ptfd.cd8_mfi_proliferation,
  ptfd.cd8_mfi_cd25,
  ptfd.cd8_percent_proliferation,
  ptfd.cd8_percent_cd25,
  ptfd.cd8_percent_cd137,
  ptfd.cd4_cell_number,
  ptfd.cd8_cell_number
FROM
  stored_data.pan_tcell_facs_data ptfd
  JOIN cte ON ptfd.uploaded_excel_file_id = cte.uploaded_excel_file_id;

COMMENT ON VIEW stored_data.vw_pan_tcell_facs_data_shiny IS 'View to join the metadata to the associated FACS data for presentation in Shiny pages.'

CREATE OR REPLACE FUNCTION isnumeric(text) RETURNS BOOLEAN AS $$
DECLARE x NUMERIC;
BEGIN
    x = $1::NUMERIC;
    RETURN TRUE;
EXCEPTION WHEN others THEN
    RETURN FALSE;
END;
$$
STRICT
LANGUAGE plpgsql IMMUTABLE;
COMMENT ON FUNCTION isnumeric(text) IS $qq$ Purpose: Check if the given argument is a number. Used to check substrings created by splitting strings into arrays. Copied verbatim from this source: http://stackoverflow.com/questions/16195986/isnumeric-with-postgresql. $qq$;


-- Called by Excel VBA to load assay data into PostgreSQL
CREATE OR REPLACE FUNCTION load_transit_tmp(p_row_values TEXT)
RETURNS TEXT
AS
$$
BEGIN
  INSERT INTO transit_tmp(data_row) VALUES(p_row_values);
  RETURN '1';
EXCEPTION
  WHEN OTHERS THEN RETURN SQLERRM;
END;
$$
LANGUAGE plpgsql;
COMMENT ON FUNCTION load_transit_tmp(TEXT) IS 'Load the given value into table "transit_tmp". Return 1 as a string on success, otherwise return the error message. Loaded value is expected to be a tab-separated string.';

DROP VIEW IF EXISTS stored_data.vw_pan_tcell_facs_data_columns;
CREATE OR REPLACE VIEW stored_data.vw_pan_tcell_facs_data_columns AS
SELECT
  column_name data_column_name
FROM
  information_schema.columns
WHERE
  table_schema = 'stored_data'
  AND
    table_name = 'pan_tcell_facs_data'
  AND
    data_type = 'real'
ORDER BY 1;
COMMENT ON VIEW stored_data.vw_pan_tcell_facs_data_columns IS $qq$
Purpose: Provides a list of columns for the pan T cell FACS data to the Shiny UI drop-down list that can be queried.
$qq$;

CREATE OR REPLACE FUNCTION delete_mean_and_sd()
RETURNS INTEGER
AS
$$
DECLARE
  l_delete_rowcount INTEGER;
BEGIN
  DELETE
  FROM
    stored_data.pan_tcell_facs_data
  WHERE
    raw_data_name IN('Mean', 'SD');
  GET DIAGNOSTICS l_delete_rowcount := ROW_COUNT;
  RETURN l_delete_rowcount;
END;
$$
LANGUAGE plpgsql;
COMMENT ON FUNCTION delete_mean_and_sd() IS
$qq$
Purpose: Delete any rows in table "stored_data.pan_tcell_facs_data" where the raw data name is either "SD" or "Mean".
Arguments: None.
Returns: The number of rows deleted.
These are added by the FACS analysis software and are not needed but they appear in the loaded spreadsheets.
Example invocation: SELECT delete_mean_and_sd();
$qq$;

CREATE OR REPLACE FUNCTION get_cd3_concentration(p_sample_id  TEXT)
RETURNS REAL
AS
$$
DECLARE
  l_cd3_concentration TEXT;
  l_cd3_concentration_as_real REAL;
BEGIN
  SELECT (REGEXP_MATCHES(p_sample_id, '^[0-9.]*'))[1] INTO l_cd3_concentration;
  IF isnumeric(l_cd3_concentration) THEN
    l_cd3_concentration_as_real := CAST(l_cd3_concentration AS REAL);
  ELSIF LENGTH(l_cd3_concentration) < 1 THEN
    l_cd3_concentration_as_real := NULL;
  ELSE
    RAISE EXCEPTION 'Cannot extract an antibody concentration!';
  END IF;
  RETURN l_cd3_concentration_as_real;
END;
$$
LANGUAGE plpgsql;
COMMENT ON FUNCTION get_cd3_concentration(TEXT) IS
$qq$
Purpose: To extract the CD3 antibody concentration from the given identifier and return it as REAL.
Assumes: The CD3 antibody concentration makes up the first part of the sample identifier.
Example Invocation: SELECT get_cd3_concentration('0.5CD3_2.5_CD28');
$qq$;

-- Functions added for doing basic stats on results that are returned in the data frmae

CREATE OR REPLACE FUNCTION get_array_std_err_mean(p_values REAL[])
RETURNS REAL
AS
$$
DECLARE
  l_array_stddev REAL := get_array_stddev(p_values);
  l_array_element_count INTEGER := ARRAY_LENGTH(p_values, 1);
  l_std_err_mean REAL;
BEGIN
  l_std_err_mean := l_array_stddev/SQRT(l_array_element_count);
  RETURN l_std_err_mean;
END;
$$
LANGUAGE plpgsql
  IMMUTABLE;
COMMENT ON FUNCTION get_array_std_err_mean(REAL[]) IS
$qq$
Purpose: To calculate and return the standard error of the mean for an array of real number values.
Example call: SELECT get_array_std_err_mean(ARRAY[80, 77.4]);
Depends on: get_array_stddev(REAL[]) to calculate the sample standard deviation.
$qq$;

CREATE OR REPLACE FUNCTION get_array_stddev(p_values REAL[])
RETURNS REAL
AS
$$
DECLARE
  l_array_stddev REAL;
BEGIN
  WITH cte AS (
    SELECT UNNEST(p_values) array_value
  )
  SELECT
    STDDEV_SAMP(array_value) INTO l_array_stddev
  FROM
    cte;
  RETURN l_array_stddev;
END;
$$
LANGUAGE plpgsql
  IMMUTABLE;

COMMENT ON FUNCTION get_array_stddev(REAL[]) IS
$qq$
Purpose: To calculate the sample standard deviation for a given array of real numbers.
Example call: SELECT get_array_stddev(ARRAY[80, 77.4]);
$qq$;


CREATE OR REPLACE FUNCTION get_delimited_str_as_numeric_array(p_delimited_str TEXT)
RETURNS REAL[]
AS
$$
BEGIN
  RETURN REGEXP_SPLIT_TO_ARRAY(p_delimited_str, E'[ ,]+')::REAL[];
EXCEPTION WHEN OTHERS THEN
    RETURN NULL;
END;
$$
LANGUAGE plpgsql
  IMMUTABLE;

COMMENT ON FUNCTION get_delimited_str_as_numeric_array(TEXT) IS
$qq$
Purpose: Return the replicates text as an array of real numbers.
Example call: SELECT get_delimited_str_as_numeric_array('80, 76.3');
Note: Returns NULL if the extracted values cannot be converted to real numbers
$qq$;

